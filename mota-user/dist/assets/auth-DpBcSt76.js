import{e as U,g as P,R as T}from"./index-jJjkrASA.js";const L={},A=e=>{let s;const o=new Set,a=(v,d)=>{const u=typeof v=="function"?v(s):v;if(!Object.is(u,s)){const f=s;s=d??(typeof u!="object"||u===null)?u:Object.assign({},s,u),o.forEach(m=>m(s,f))}},l=()=>s,S={setState:a,getState:l,getInitialState:()=>c,subscribe:v=>(o.add(v),()=>o.delete(v)),destroy:()=>{(L?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),o.clear()}},c=s=e(a,l,S);return S},$=e=>e?A(e):A;var R={exports:{}},D={},j={exports:{}},x={};var H;function J(){if(H)return x;H=1;var e=U();function s(d,u){return d===u&&(d!==0||1/d===1/u)||d!==d&&u!==u}var o=typeof Object.is=="function"?Object.is:s,a=e.useState,l=e.useEffect,t=e.useLayoutEffect,y=e.useDebugValue;function g(d,u){var f=u(),m=a({inst:{value:f,getSnapshot:u}}),r=m[0].inst,n=m[1];return t(function(){r.value=f,r.getSnapshot=u,S(r)&&n({inst:r})},[d,f,u]),l(function(){return S(r)&&n({inst:r}),d(function(){S(r)&&n({inst:r})})},[d]),y(f),f}function S(d){var u=d.getSnapshot;d=d.value;try{var f=u();return!o(d,f)}catch{return!0}}function c(d,u){return u()}var v=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?c:g;return x.useSyncExternalStore=e.useSyncExternalStore!==void 0?e.useSyncExternalStore:v,x}var W;function N(){return W||(W=1,j.exports=J()),j.exports}var k;function M(){if(k)return D;k=1;var e=U(),s=N();function o(c,v){return c===v&&(c!==0||1/c===1/v)||c!==c&&v!==v}var a=typeof Object.is=="function"?Object.is:o,l=s.useSyncExternalStore,t=e.useRef,y=e.useEffect,g=e.useMemo,S=e.useDebugValue;return D.useSyncExternalStoreWithSelector=function(c,v,d,u,f){var m=t(null);if(m.current===null){var r={hasValue:!1,value:null};m.current=r}else r=m.current;m=g(function(){function h(b){if(!i){if(i=!0,p=b,b=u(b),f!==void 0&&r.hasValue){var _=r.value;if(f(_,b))return E=_}return E=b}if(_=E,a(p,b))return _;var z=u(b);return f!==void 0&&f(_,z)?(p=b,_):(p=b,E=z)}var i=!1,p,E,w=d===void 0?null:d;return[function(){return h(v())},w===null?void 0:function(){return h(w())}]},[v,d,u,f]);var n=l(c,m[0],m[1]);return y(function(){r.hasValue=!0,r.value=n},[n]),S(n),n},D}var C;function G(){return C||(C=1,R.exports=M()),R.exports}var B=G();const K=P(B),q={},{useDebugValue:Q}=T,{useSyncExternalStoreWithSelector:X}=K;let F=!1;const Y=e=>e;function Z(e,s=Y,o){(q?"production":void 0)!=="production"&&o&&!F&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),F=!0);const a=X(e.subscribe,e.getState,e.getServerState||e.getInitialState,s,o);return Q(a),a}const O=e=>{(q?"production":void 0)!=="production"&&typeof e!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const s=typeof e=="function"?$(e):e,o=(a,l)=>Z(s,a,l);return Object.assign(o,s),o},V=e=>e?O(e):O,ee={};function te(e,s){let o;try{o=e()}catch{return}return{getItem:l=>{var t;const y=S=>S===null?null:JSON.parse(S,void 0),g=(t=o.getItem(l))!=null?t:null;return g instanceof Promise?g.then(y):y(g)},setItem:(l,t)=>o.setItem(l,JSON.stringify(t,void 0)),removeItem:l=>o.removeItem(l)}}const I=e=>s=>{try{const o=e(s);return o instanceof Promise?o:{then(a){return I(a)(o)},catch(a){return this}}}catch(o){return{then(a){return this},catch(a){return I(a)(o)}}}},re=(e,s)=>(o,a,l)=>{let t={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:n=>n,version:0,merge:(n,h)=>({...h,...n}),...s},y=!1;const g=new Set,S=new Set;let c;try{c=t.getStorage()}catch{}if(!c)return e((...n)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),o(...n)},a,l);const v=I(t.serialize),d=()=>{const n=t.partialize({...a()});let h;const i=v({state:n,version:t.version}).then(p=>c.setItem(t.name,p)).catch(p=>{h=p});if(h)throw h;return i},u=l.setState;l.setState=(n,h)=>{u(n,h),d()};const f=e((...n)=>{o(...n),d()},a,l);let m;const r=()=>{var n;if(!c)return;y=!1,g.forEach(i=>i(a()));const h=((n=t.onRehydrateStorage)==null?void 0:n.call(t,a()))||void 0;return I(c.getItem.bind(c))(t.name).then(i=>{if(i)return t.deserialize(i)}).then(i=>{if(i)if(typeof i.version=="number"&&i.version!==t.version){if(t.migrate)return t.migrate(i.state,i.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return i.state}).then(i=>{var p;return m=t.merge(i,(p=a())!=null?p:f),o(m,!0),d()}).then(()=>{h?.(m,void 0),y=!0,S.forEach(i=>i(m))}).catch(i=>{h?.(void 0,i)})};return l.persist={setOptions:n=>{t={...t,...n},n.getStorage&&(c=n.getStorage())},clearStorage:()=>{c?.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>r(),hasHydrated:()=>y,onHydrate:n=>(g.add(n),()=>{g.delete(n)}),onFinishHydration:n=>(S.add(n),()=>{S.delete(n)})},r(),m||f},ne=(e,s)=>(o,a,l)=>{let t={storage:te(()=>localStorage),partialize:r=>r,version:0,merge:(r,n)=>({...n,...r}),...s},y=!1;const g=new Set,S=new Set;let c=t.storage;if(!c)return e((...r)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),o(...r)},a,l);const v=()=>{const r=t.partialize({...a()});return c.setItem(t.name,{state:r,version:t.version})},d=l.setState;l.setState=(r,n)=>{d(r,n),v()};const u=e((...r)=>{o(...r),v()},a,l);l.getInitialState=()=>u;let f;const m=()=>{var r,n;if(!c)return;y=!1,g.forEach(i=>{var p;return i((p=a())!=null?p:u)});const h=((n=t.onRehydrateStorage)==null?void 0:n.call(t,(r=a())!=null?r:u))||void 0;return I(c.getItem.bind(c))(t.name).then(i=>{if(i)if(typeof i.version=="number"&&i.version!==t.version){if(t.migrate)return[!0,t.migrate(i.state,i.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,i.state];return[!1,void 0]}).then(i=>{var p;const[E,w]=i;if(f=t.merge(w,(p=a())!=null?p:u),o(f,!0),E)return v()}).then(()=>{h?.(f,void 0),f=a(),y=!0,S.forEach(i=>i(f))}).catch(i=>{h?.(void 0,i)})};return l.persist={setOptions:r=>{t={...t,...r},r.storage&&(c=r.storage)},clearStorage:()=>{c?.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>m(),hasHydrated:()=>y,onHydrate:r=>(g.add(r),()=>{g.delete(r)}),onFinishHydration:r=>(S.add(r),()=>{S.delete(r)})},t.skipHydration||m(),f||u},oe=(e,s)=>"getStorage"in s||"serialize"in s||"deserialize"in s?((ee?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),re(e,s)):ne(e,s),ie=oe,ae=V()(ie(e=>({user:null,token:null,isAuthenticated:!1,login:(s,o)=>{e({user:s,token:o,isAuthenticated:!0})},logout:()=>{e({user:null,token:null,isAuthenticated:!1})},updateUser:s=>{e(o=>({user:o.user?{...o.user,...s}:null}))}}),{name:"mota-auth-storage",partialize:e=>({user:e.user,token:e.token,isAuthenticated:e.isAuthenticated})}));export{ae as u};
